package com.example.cooksy.viewModel.supermarket // Or your preferred ViewModel package

import android.util.Log // For logging errors
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.cooksy.data.model.supermarket.SupermarketItem
import com.example.cooksy.data.repository.AuthRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
// UUID might not be needed here if IDs are generated by Firestore or passed in
// import java.util.UUID

class SupermarketViewModel(
    private val authRepository: AuthRepository = AuthRepository() // Assuming default constructor
) : ViewModel() {

    private val _supermarketItems = MutableStateFlow<List<SupermarketItem>>(emptyList())
    val supermarketItems: StateFlow<List<SupermarketItem>> = _supermarketItems.asStateFlow()

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    // Consider adding a StateFlow for error messages to show in UI
    // private val _errorMessage = MutableStateFlow<String?>(null)
    // val errorMessage: StateFlow<String?> = _errorMessage.asStateFlow()

    init {
        // Load items when the ViewModel is created if the user is logged in
        if (authRepository.isUserLoggedIn()) {
            loadSupermarketItems()
        }
    }

    fun loadSupermarketItems() {
        viewModelScope.launch {
            _isLoading.value = true
            // _errorMessage.value = null // Clear previous errors
            val userId = authRepository.currentUser?.uid
            if (userId != null) {
                val result = authRepository.getSupermarketList(userId)
                result.onSuccess { items ->
                    _supermarketItems.value = items
                }.onFailure { exception ->
                    Log.e("SupermarketViewModel", "Error loading items: ${exception.message}", exception)
                    // _errorMessage.value = "Error al cargar la lista: ${exception.message}"
                    _supermarketItems.value = emptyList() // Clear list on error or keep stale data?
                }
            } else {
                Log.w("SupermarketViewModel", "User not logged in, cannot load items.")
                // _errorMessage.value = "Usuario no autenticado."
                _supermarketItems.value = emptyList() // No user, no items
            }
            _isLoading.value = false
        }
    }

    fun addItem(name: String, quantity: String, price: Double?) {
        viewModelScope.launch {
            val userId = authRepository.currentUser?.uid
            if (userId == null) {
                Log.w("SupermarketViewModel", "User not logged in, cannot add item.")
                // _errorMessage.value = "Debes iniciar sesión para añadir artículos."
                return@launch
            }
            // ID will be generated by SupermarketItem or can be generated here if needed
            val newItem = SupermarketItem(
                // id = UUID.randomUUID().toString(), // Firestore can auto-generate IDs if we don't set one
                name = name,
                quantity = quantity,
                price = price,
                userId = userId,
                dateAdded = System.currentTimeMillis() // Ensure dateAdded is set
            )
            _isLoading.value = true
            val result = authRepository.addSupermarketItem(newItem)
            result.onSuccess {
                // Option 1: Add to local list (faster UI update)
                // _supermarketItems.value = _supermarketItems.value + newItem
                // Option 2: Reload the entire list from Firestore (more consistent)
                loadSupermarketItems() // This will also set isLoading to false eventually
            }.onFailure { exception ->
                Log.e("SupermarketViewModel", "Error adding item: ${exception.message}", exception)
                // _errorMessage.value = "Error al añadir el artículo: ${exception.message}"
                _isLoading.value = false
            }
            // If not calling loadSupermarketItems() on success, set isLoading to false here
            // _isLoading.value = false
        }
    }

    fun toggleItemChecked(itemId: String, isChecked: Boolean) {
        viewModelScope.launch {
            val itemToUpdate = _supermarketItems.value.find { it.id == itemId }
            if (itemToUpdate == null) {
                Log.w("SupermarketViewModel", "Item not found for toggling: $itemId")
                // _errorMessage.value = "Artículo no encontrado."
                return@launch
            }

            // Ensure userId is present (it should be if it came from the list)
            if (itemToUpdate.userId.isEmpty()) {
                 Log.e("SupermarketViewModel", "UserID is missing in item to update: $itemId")
                // _errorMessage.value = "Error de datos del artículo."
                return@launch
            }

            val updatedItem = itemToUpdate.copy(isChecked = isChecked)
            _isLoading.value = true
            val result = authRepository.updateSupermarketItem(updatedItem)
            result.onSuccess {
                // Update local list
                _supermarketItems.value = _supermarketItems.value.map {
                    if (it.id == itemId) updatedItem else it
                }
            }.onFailure { exception ->
                Log.e("SupermarketViewModel", "Error toggling item: ${exception.message}", exception)
                // _errorMessage.value = "Error al actualizar el artículo: ${exception.message}"
            }
            _isLoading.value = false
        }
    }

    fun updateItem(itemToUpdate: SupermarketItem) {
        viewModelScope.launch {
            if (itemToUpdate.userId.isEmpty() || itemToUpdate.id.isEmpty()) {
                Log.e("SupermarketViewModel", "UserID or ItemID is missing in item for update.")
                // _errorMessage.value = "Datos incompletos para actualizar el artículo."
                return@launch
            }
            _isLoading.value = true
            val result = authRepository.updateSupermarketItem(itemToUpdate)
            result.onSuccess {
                // Update local list
                _supermarketItems.value = _supermarketItems.value.map {
                    if (it.id == itemToUpdate.id) itemToUpdate else it
                }
                 // Or reload the whole list: loadSupermarketItems()
            }.onFailure { exception ->
                Log.e("SupermarketViewModel", "Error updating item: ${exception.message}", exception)
                // _errorMessage.value = "Error al modificar el artículo: ${exception.message}"
            }
            _isLoading.value = false
        }
    }

    fun deleteItem(itemId: String) {
        viewModelScope.launch {
            if (itemId.isEmpty()){
                Log.w("SupermarketViewModel", "ItemID is empty, cannot delete.")
                return@launch
            }
            _isLoading.value = true
            val result = authRepository.deleteSupermarketItem(itemId)
            result.onSuccess {
                // Remove from local list
                _supermarketItems.value = _supermarketItems.value.filterNot { it.id == itemId }
                // Or reload the whole list: loadSupermarketItems()
            }.onFailure { exception ->
                Log.e("SupermarketViewModel", "Error deleting item: ${exception.message}", exception)
                // _errorMessage.value = "Error al eliminar el artículo: ${exception.message}"
            }
            _isLoading.value = false
        }
    }

    fun getItemById(itemId: String): SupermarketItem? {
        return _supermarketItems.value.find { it.id == itemId }
    }

    // Call this if you need to clear the list on logout, for example
    fun clearSupermarketData() {
        _supermarketItems.value = emptyList()
        // _errorMessage.value = null
    }
}
